% NOTE: xHPTDC has a seperate file describing the readout

%%%%%%%%%%%%%%%%% run time control
\section{Run Time Control}

Once the devices are configured the following functions can be used to control the behaviour of the devices. 
All of these functions return quickly with very little overhead, but they are not guaranteed to be thread safe.

	\ttvar{int}{start\tu capture(}\device)\\
	Start data acquisition.\par

	\ttvar{int}{pause\tu capture(}\device)\\
	Pause a started data acquisition. 
	Pause and continue have less overhead than start and stop but don't allow for a configuration change.\par

	\ttvar{int}{continue\tu capture(}\device)\\
	Call this to resume data acquisition after a call to \textsf{\prefix pause\tu capture()}.
	Pause and continue have less overhead than start and stop but don't allow for a configuration change.\par

	\ttvar{int}{stop\tu capture(}\device)\\
	Stop data acquisition.\par
	
	\ttvar{int}{start\tu tiger(}\device)\\
	\ttvar{int}{stop\tu tiger(}\device)\\
	Start and stop the timing generator. This can be done independently of the state of the data acquisition.\par	

%%%%%% readout
\section{Readout}
    The device provides a stream of packets, that are read in batches. A batch of
    packets is provided to the application, it processes them, by storing important information
    in other structures. The batch that were processed need to be acknowledged, so that
    the device can reuse the memory of these for the next data. That means processing
    should be fast. 
    \begin{lstlisting}[numbers=none]
timetagger4_read_in in;
// automatically acknowledge all data as processed
in.acknowledge_last_read = 1;
volatile crono_packet* p = read_data.first_packet;
timetagger4_read_out out;
int status = timetagger4_read(device, &in, &out);
if (status == CRONO_READ_OK) {
    while (p <= read_data.last_packet)
    {
        processPacket(p);
        p = crono_next_packet(p);
    }    
}
        \end{lstlisting}
    
	\ttvar{int}{acknowledge(}\device, \cronvar{crono\tu packet}{*packet)}\\
	Acknowledges the processing of the last read block. This is only necessary if \textsf{\prefix read()} is not called with 
	\textsf{in.acknowledge\tu last\tu read} set.\\
	This feature allows to either free up partial DMA space early if there will be no call to \textsf{\prefix read()} anytime soon. 
	It also allows to keep data over multiple calls to \textsf{\prefix read()} to avoid unnecessary copying of data. \par

	\ttvar{int}{read(}\device \cronvar{\prefix read\tu in}{*in,} \\ \cronvar{\prefix read\tu out}{*out)}\\
	Return a pointer to an array of captured data in \textsf{read\tu out}.
	The result contains a batch of packets of type \textsf{\prefix packet}. The batch
    is described by first\tu packet and last\tu packet in the \cronvar{\prefix read\tu in structure}.
    
	\textsf{read\tu in} provides parameters to the driver. 
	A call to this method automatically allows the driver to reuse the memory returned in the previous call if \textsf{read\tu in.acknowledge\tu last\tu read} is set.\\
	Returns an error code as defined in the structure \textsf{\prefix read\tu out}.

    	
    \cronvar{crono\tu packet}{crono\tu next\tu packet(}\cronvar{crono\tu packet}{*packet)}
    Iterates to the next packet in the batch. 

	\subsection{Input Structure \prefix read\tu in}

		\cronvar{crono\tu bool\tu t}{acknowledge\tu last\tu read}\\
		If set \textsf{\prefix read()} automatically acknowledges packets from the last read. 
		Otherwise \textsf{\prefix acknowledge()} needs to be called explicitly by the user. 

	\subsection{Input Structure \prefix read\tu out}
		\cronvar{crono\tu packet}{*first\tu packet}\\
		Pointer to the first packet that was captured by the call of \textsf{\prefix read()}.\par

		\cronvar{crono\tu packet}{*last\tu packet}\\
		Address of header of the last packet in the buffer. This packet is still valid, all data after this packet is invalid.\par

		\cronvar{int}{error\tu code}\\
		Assignments of the error codes.\par
		\begin{tabular}{lc}
			\crondef{CRONO\tu READ\tu OK} & 0\\
			\crondef{CRONO\tu READ\tu NO\tu DATA} & 1\\
			\crondef{CRONO\tu READ\tu INTERNAL\tu ERROR} & 2\\
			\crondef{CRONO\tu READ\tu TIMEOUT} & 3\par
		\end{tabular}\par

		\cronvar{const char}{*error\tu message}
		The last error in human readable form, possibly with additional information about the error.

	